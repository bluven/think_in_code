# 友善待人，编写稳定的代码

---
[原文](http://technosophos.com/2018/07/04/be-nice-and-write-stable-code.html)
---
停止重构你的代码！专业的开发者重视稳定性甚于“代码纯洁性”。不要在每次发布中追求完美代码，善待他人，开发稳定的API。这篇文章中，我将讨论如何实践编写代码并保持稳定。

## The Non-Goal

当开始写代码时，这样的建议毫无益处：

    > 当你写代码时，要做到不会过时

如果历史教会我们什么东西，那就是我们都是差劲的未来预言家。努力保证API干净，设计灵活，深思熟虑的默认值当然是好得实践。但不可避免的是，你的用户或突发需求总会给你惊喜。

我想讨论的是如何应对好这些惊喜，如何避免给你的用户带去惊喜（和挫折）。

## 版本号与语义版本号

在软件中，我们使用版本号来告知有些东西改变了。版本号策略有极其简单的（每个版本递增的数字或时间戳），也有极其复杂的（1.0~pre3+dfsg-0.1+b2, 2.1.1+git20160721~8efc468-2 和 1.2.0+LibO5.2.7-1+deb9u4 )

但当说及软件版号，现在处于领先地位的版本号方案是SemVer（语义化版本）。不要被愚弄了！许多人号称直到语义化版本怎么回事，但其实并未读过规范。因为这将是我们要讨论的关键内容，这里是规范的一个摘要：
 
 版本号采用`X.Y.Z`的形式，有时候会有额外的预发布和构建信息：`X.Y.Z-AAA#BBB`。每个字段都有特定明确的含义：
 
 * `X`是大版本号。每次变化意味着API或行为的破坏性改变。
 * `Y`是小版本号。每次变化意味着新特性的添加，但API本身没有破坏性变化。 
 * `Z`是补丁版本号。每次变化意味着内部发生了变化，但API没有（甚至是兼容性）变化。

这3点对我们至关重要。再一次，我建议花10分钟阅读整个规范。

数不清的项目使用了看着像语义化版本的版本格式，但很多忽略了版本号后面的语义。经常能看到版本号是根据直觉递增了，而不是一致性的语义：这看起来像是个小的版本更新。

这篇文章的目的是阐述如何开发真正遵循语义化版本的软件，摆脱“凭直觉”的版本，让你的用户保持心态和平。

## 为何这么做？

为何要使用语义化版本方案呢？随意更新版本号有什么问题？原因很简单：版本号可以帮你的用户了解他们期待的变化的本质。如果你不遵循某种模式，他们只能猜测，这通常让人沮丧。

遵循语义化版本为两个方面带来了精确：

1. 发出明确的信号告知用户变化的某个发布的变化的深度
2. 发出明确的信号告知你们的开发者在改变代码时，什么可以，什么不可以。

我不能低估第二点的重要性。语义化版本帮助我们强制自律，反过来最小化内部和外部的破坏。

## 变化的模式

既然语义化版本不再是个问题，现在我们讨论一下真正的变动模式

记住，代码的可用性是专业软件开发者的关注点。可预测的变化模式是对可用性的极大帮助。

### 重新组织，重构和重命名

没有更清晰的方式来说明这点了：如果你重新组织你的公开API的包结构，或者你在做一次大的重命名，或者你选择改变你的公开API的方法/结构体/类等等，你必须递增大版本号。

就是这样。没有灰色空间。这样的改变意味着任何使用你代码的人都可能遇到破坏。

当进行小的更新时，意味着要保持自律。是的，包的结构可能很糟糕。是的，代码可能很丑陋。但你必须等到合适的时刻来解决这个问题。

当然，在不触及公开API的情况下，可以做一些内部改变。所以，小的内部重构只能在小的更新，甚至不定或发布中进行（我们并不建议在补丁版进行）。

> 注意：别试图用“公开但内部”的理由作辩解。如果语法规定了这是公开的，那就是公开的，你的意图无补于此。

所以实际上，下面这些除了在大的更新中都不该改变：

* 包结构
* 公开类，结构体，枚举，结构等等。常量或公开变量的名字，还有他们的值。
* 函数/方法名
* 现存函数/方法签名，除非这种变化是递增的，并且递增的值是可选的。返回的数据类型及异常也不能变。

底线：重构，重命名和重组织是甜蜜的诱惑。但做小的或补丁发布时，必须拒绝这种诱惑。专业软件开发者的一部分职责是创造性地应对不完美代码。

或许有人会说，那么如何在改变这些的前提下添加新特性呢？这是下面几节的主题。
