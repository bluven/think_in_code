# 友善待人，编写稳定的代码

---
[原文](http://technosophos.com/2018/07/04/be-nice-and-write-stable-code.html)
---
停止重构你的代码！专业的开发者重视稳定性甚于“代码纯洁性”。不要在每次发布中追求完美代码，善待他人，开发稳定的API。这篇文章中，我将讨论如何实践编写代码并保持稳定。

## The Non-Goal

当开始写代码时，这样的建议毫无益处：

    > 当你写代码时，要做到不会过时

如果历史教会我们什么东西，那就是我们都是差劲的未来预言家。努力保证API干净，设计灵活，深思熟虑的默认值当然是好得实践。但不可避免的是，你的用户或突发需求总会给你惊喜。

我想讨论的是如何应对好这些惊喜，如何避免给你的用户带去惊喜（和挫折）。

## 版本号与语义版本号

在软件中，我们使用版本号来告知有些东西改变了。版本号策略有极其简单的（每个版本递增的数字或时间戳），也有极其复杂的（1.0~pre3+dfsg-0.1+b2, 2.1.1+git20160721~8efc468-2 和 1.2.0+LibO5.2.7-1+deb9u4 )

但当说及软件版号，现在处于领先地位的版本号方案是SemVer（语义化版本）。不要被愚弄了！许多人号称知道SemVer怎么回事，但其实并未读过规范。因为这将是我们要讨论的关键内容，这里是规范的一个摘要：
 
 版本号采用`X.Y.Z`的形式，有时候会有额外的预发布和构建信息：`X.Y.Z-AAA#BBB`。每个字段都有特定明确的含义：
 
 * `X`是大版本号。每次变化意味着API或行为的破坏性改变。
 * `Y`是小版本号。每次变化意味着新特性的添加，但API本身没有破坏性变化。 
 * `Z`是补丁版本号。每次变化意味着内部发生了变化，但API没有（甚至是兼容性）变化。

这3点对我们至关重要。再一次，我建议花10分钟阅读整个规范。

数不清的项目使用了看着像语义化版本（SemVer)的版本格式，但很多忽略了版本号后面的语义。经常能看到版本号是根据直觉递增了，而不是一致性的语义：这看起来像是个小的版本更新。

这篇文章的目的是阐述如何开发真正遵循SemVer的软件，摆脱“凭直觉”的版本，让你的用户保持心态和平。

## 为何这么做？

为何要使用SemVer方案呢？随意更新版本号有什么问题？原因很简单：版本号可以帮你的用户了解他们期待的变化的本质。如果你不遵循某种模式，他们只能猜测，这通常让人沮丧。

遵循SemVer为两个方面带来了精确：

1. 发出明确的信号告知用户变化的某个发布的变化的深度
2. 发出明确的信号告知你们的开发者在改变代码时，什么可以，什么不可以。

我不能低估第二点的重要性。SemVer帮助我们强制自律，反过来最小化内部和外部的破坏。

## 变化的模式

既然SemVer不再是个问题，现在我们讨论一下真正的变动模式

记住，代码的可用性是专业软件开发者的关注点。可预测的变化模式是对可用性的极大帮助。

### 重新组织，重构和重命名

没有更清晰的方式来说明这点了：如果你重新组织你的公开API的包结构，或者你在做一次大的重命名，或者你选择改变你的公开API的方法/结构体/类等等，你必须递增大版本号。

就是这样。没有灰色空间。这样的改变意味着任何使用你代码的人都可能遇到破坏。

当进行小的更新时，意味着要保持自律。是的，包的结构可能很糟糕。是的，代码可能很丑陋。但你必须等到合适的时刻来解决这个问题。

当然，在不触及公开API的情况下，可以做一些内部改变。所以，小的内部重构只能在小的更新，甚至不定或发布中进行（我们并不建议在补丁版进行）。

> 注意：别试图用“公开但内部”的理由作辩解。如果语法规定了这是公开的，那就是公开的，你的意图无补于此。

所以实际上，下面这些除了在大的更新中都不该改变：

* 包结构
* 公开类，结构体，枚举，结构等等。常量或公开变量的名字，还有他们的值。
* 函数/方法名
* 现存函数/方法签名，除非这种变化是递增的，并且递增的值是可选的。返回的数据类型及异常也不能变。

底线：重构，重命名和重组织是甜蜜的诱惑。但做小的或补丁发布时，必须拒绝这种诱惑。专业软件开发者的一部分职责是创造性地应对不完美代码。

或许有人会说，那么如何在改变这些的前提下添加新特性呢？这是下面几节的主题。

### 引入新特性

小版本可以新特性，但这些特性必须在不破坏先有API的情况下被引入。

特性本质上是累加的：他们带来新东西，但布修改或删除已有的东西。为了实现这个目标，这些作为特性发布是安全的：

* 为结构体/类/枚举等添加字段和方法。
* 添加新的结构体/方法/枚举。或添加新的变量，常量，函数诸如此类。
* 添加新的配置项（详勘下一节）
* 将非公开的东西变为公开的（例如：将私有API暴露出来）

但有些破坏性改变在特性的掩盖下被悄悄引入，这些必须要避开：

* 改变常量或变量的值
* 改变方法或函数的签名（例如：添加更多参数或改变返回类型）
    * 除非语言支持添加可选参数，使得旧的调用依然可以工作）
* 把公开API变成非公开（隐藏API）

### 通过添加替代品来修改

假设起初编写的代码是这样的：

```
func ListItems(query Query) Items {
  // Code to fetch and list the items
}
```

假设上面的代码可能做一次数据库查询并获取所有的结果。

现在有个特性需求来了：我们需要给所有的列表函数加上分页。有人可能会这样做：
The code above might, for example, do a database query and fetch all of the results.

Now a feature request rolls in: "We need to add paging to the list functions." The temptation is to do this:
```
func ListItems(query Query, limit int, offset int) Items {
  // ...
}
```
但API被破坏了，正确的做法是引入一个新的函数：
```
func ListItems(query Query) Items {
  ListItemsWithLimit(query, 0, 0)
}

func ListItemsWithLimit(query Query, limit int, offset int) Items {
  // ...
}
```

注意，我们已经修改了旧函数的内部代码（调用新函数）来实现原先的功能。

把旧函数标记为“弃用”也没关系。事实上，这就是诸如java之类的语言为“弃用”添加内部支持的原因。专业级的开发往往包含最终移除的弃用策略，即便最终删除在数年后。

重要的是，如果新引入的函数不能复制旧的特性集合，你就有义务（除非是因为安全因素）尽最大可能提供旧API的功能。

### 警惕不可靠的变通

有种可接受的模式在很多事情上效果良好，但有些开发者用来绕过SemVer的限制来修改函数签名：

```
func ListItems(query Query, options Map) Items {
   // ...
}
```
在这种模式中，这个`option` map是任意的键值选项。这个模式本身是好的，除非默认行为被一个新的选项改变。当添加新的选项时，专业开发者确保当选项不存在时，代码功能与上一次发布一样。

## 即将弃用

前面我们提及了弃用。但我想概述一下弃用策略：

* 一旦有个东西被视为弃用的，就尽快做上标记，即便是在小更新或补丁发布中。弃用毕竟是个警告情况，而不是错误情况。
* 不要在小更新或补丁发布中修改弃用功能的行为
* 只在大版本更新中移除弃用功能。在此之前，你仍旧需要支持它们。

弃用是某个东西在将来可能会被删除的信号。但这不是一个跳出SemVer限制来改变，删除或忽视这部分代码的功能的理由。

## 错误和异常

## Errors and Exceptions

我曾遇到过的最让人郁闷的中断是一个来自上游库的看似无害的改变：在小更新发布中，这个库改变了因为某个错误抛出的异常的类型。

这个库中的一个函数每当遇到网络错误时都会抛出IOException，遇到其他错误则抛出其他异常：

我们抛出IOException来开始重试逻辑。因为网络错误是个高发错误，这是个重要的特性。

但是在一次小的版本变化中，开发者决定简化API，他们捕获了所有不同的异常（包括IOException）并封装到一个泛型异常中。(意外地，这个API本身没有改变，它是类似Read(in Reader) error, error是所有异常的父类）。

当我们升级时，我们所有的测试用例都通过了（因为我们的测试固件模仿了旧的行为，而且我们的网络稳定到不能触发这个条件），产品就跟正常一样发布了。但客户开始抱怨我们的产品有点不可靠。为何？因为重试逻辑从不触发。所以我们的APP就跟它所依赖的网络一样不稳定。

底线：错误处理是你公开API的一部分。

## 拒绝微妙的改变

有时候微妙但规划有问题的改变可能为你的客户带来大的破坏。

这里讲述一个小故事：我们众多依赖中的一个无足轻重的改变却导致我们客户产品的一系列灾难

我们依赖一个库来提供C/S RPC协议。这个库很久以来都被标为稳定的，实际上稳定性是该库的诸多宣传特性中的一个。但开发者们引入了一个看似遵循稳定性需求的小变动，但实际上带来严重的兼容性问题。这个改变是这样的：

这个库允许我们设置消息最大尺寸，默认值是256k，但我们想让它更大点。所以我们设置了这个选项：
```
config.MaxMesageSize = 1024
```
这使得客户端和服务器相互可以发送大至1M的消息。但在某个地方，这个包的小版本发布做了一个极微小但致命的变化：
他们把上游和下游消息的尺寸放到2个变量中。致命的地方在于：他们仅仅新创建了一个变量（config.MaxInboundMessageSize)，并改变第一个选项来影响外出消息尺寸。

当我们升级这个包后，一切看似工作正常。代码编译了，测试通过了。早起的用户没看到任何问题。然后我们就发布了包含这个更新依赖的新版本。突然愤怒的用户开始提交问题。昨天还能工作的东西今天就不能用了。

为什么呢？流入的消息尺寸从1M跌入到默认的256k。而我们早期测试发送的消息小于256k，但有很多产品这么做了。

上游库维护人员悄悄改变他们的代码，引入了一个严重的bug到我们的代码中，甚至没有(死板地）打破SemVer限制。

那么他们该怎么做呢？

我同意在小版本中把尺寸限制分为流出流入两种完全合理，只是做法错误了。

正确的做法是声明像这样的引入新变量的配置变化，并为旧变量添加默认支持
 
实际上，应该像这样：

```
type Config struct {
   // Old one
   MaxMessageSize int
   // New settings
   MaxInboundMessageSize int
   MaxOutboundMessageSize int
}
```
然后库的内部代码处理这种遗留情况并提供新的功能：

```
// Support clients who set the old config
if config.MaxMessageSize > 0 {
    config.MaxInboundMessageSize = config.MaxMessageSize
    config.MaxOutboundMessageSize = config.MaxMessageSize
}
```
在基础库中采用类似的方法，任何使用它的工具都可以通过旧的参数继续使用旧的功能，或者选择新的选项。

## Bug和安全修复：如何处理现实生活

多数时候遵循“决不改变某些东西”的指引没有问题，直到现实来电。但如果公开常量或变量引入一个安全问题或导致服务器宕机？

当现实世界问题介入时，我们特殊对待。但专业的开发者小心巧妙地执行。

重要的概念是最小化侵入性改变。也就是说，当发布bug补丁或安全版本时，我们或许需要改变API，但我们应该尽量做最小最少的变动。即便这意味着牺牲“架构纯洁性“，我们也该如此。

引入一个全局变量作为权宜之计来修复一个函数而不改变函数，我承认这很丑陋。我觉得惭愧。但这确保了向后兼容性，这才是重要的事。如果我修改了函数调用，数千用户需要修改他们的代码。但通过这个丑陋的全局变量，只有部分需要调整被影响的特定参数（而且仅仅把选项设为他们以前不能控制的值）。

但一个安全问题或大的bug是一个合理的原因来改变诸如默认值或者甚至更大的宏观的行为。如果改变太大，你依然有义务改变代码的大版本号。SemVer没有不为这种情况放行，没做到这点会渐渐失去我们的信心。

但对小的侵入性改变，我个人觉得你可以做一些违反SemVer的小版本，假如：

* 在你的发布记录中声明：
    "The value of MaxBufferSize was adjusted downward to 2048 because we discovered a buffer overflow in a lower level library for any larger buffer size. See issue #4144"
* 代码明确添加注释：
```
// MaxBufferSize sets the maximum size of the network buffer.
// Prior to version 2.5.1, this was 4096. Due to a security flaw
// reported in #4144 that resulted in a buffer overflow, we
// lowered this to 2048.
MaxBufferSize = 2048
```

## 结论

专业的开发者将长期的可用性和稳定性作为目标。是的，良好架构的代码很重要。但有个事件和地方集中做这些。维护性发布（小版本和补丁版本）不是做重构，重新组织或彻底大变动的时机。

认真对待你的代码的用户使用你的代码的努力。我可以根据经验考诉你当你把强加给我们的维护负担变得令人厌烦时，我们会停止使用你的工具（或者fork它）。

SemVer是一个沟通工具。但为了用好它，我们需要准确地使用。这意味着开发重在稳定的代码。
